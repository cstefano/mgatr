using System.Text;
using Microsoft.SqlServer.Management.Smo;

namespace Migratonator;

internal class SchemaDumpCommand : BaseCommand
{
    public SchemaDumpCommand(Options configuration) :
        base(configuration)
    {
    }

    public override void Perform()
    {
        Console.WriteLine($"Dumping '{Options.DatabaseName}' database schema to file...");

        // every possible option is available here:
        var scriptOptions = new ScriptingOptions
        {
            ScriptForCreateDrop = false,
            ScriptForCreateOrAlter = false,
            ScriptForAlter = false,
            // DriWithNoCheck = true,
            IncludeFullTextCatalogRootPath = true,
            SpatialIndexes = true,
            ColumnStoreIndexes = true,
            ScriptDrops = false,
            // AnsiFile = true,
            // AppendToFile = true,
            // ToFileOnly = true,
            SchemaQualify = true,
            IncludeHeaders = false,
            IncludeScriptingParametersHeader = false,
            // IncludeIfNotExists = true,
            WithDependencies = true,
            DriPrimaryKey = true,
            DriForeignKeys = true,
            DriUniqueKeys = true,
            DriClustered = true,
            DriNonClustered = true,
            DriChecks = true,
            DriDefaults = true,
            Triggers = true,
            Statistics = false,
            ClusteredIndexes = true,
            NonClusteredIndexes = true,
            NoAssemblies = false,
            // PrimaryObject = true,
            // Default = true,
            XmlIndexes = true,
            FullTextCatalogs = true,
            FullTextIndexes = true,
            FullTextStopLists = true,
            Indexes = true,
            DriIndexes = true,
            DriAllKeys = true,
            DriAllConstraints = true,
            DriAll = true,
            Bindings = true,
            NoFileGroup = false,
            NoFileStream = false,
            NoFileStreamColumn = false,
            NoCollation = true,
            ContinueScriptingOnError = false,
            IncludeDatabaseRoleMemberships = false,
            Permissions = true, /* users get included otherwise */
            AllowSystemObjects = false,
            NoIdentities = false,
            // ConvertUserDefinedDataTypesToBaseType = true,
            // TimestampToBinary = true,
            AnsiPadding = false,
            ExtendedProperties = true,
            // DdlHeaderOnly = true,
            // DdlBodyOnly = true,
            // NoViewColumns = true,
            SchemaQualifyForeignKeysReferences = true,
            AgentAlertJob = true,
            AgentJobId = false,
            AgentNotify = true,
            // LoginSid = true,
            // NoCommandTerminator = true,
            // NoIndexPartitioningSchemes = true,
            // NoTablePartitioningSchemes = true,
            IncludeDatabaseContext = true,
            NoXmlNamespaces = false,
            DriIncludeSystemNames = true,
            OptimizerData = false,
            // NoExecuteAs = true,
            EnforceScriptingOptions = true,
            NoMailProfileAccounts = true,
            NoMailProfilePrincipals = true,
            // NoVardecimal = true,
            // ChangeTracking = true,
            ScriptDataCompression = true,
            ScriptXmlCompression = true,
            ScriptSchema = true,
            ScriptData = false,
            ScriptBatchTerminator = true,
            ScriptOwner = false
        };

        // FIXME: figure out further scripting options to control
        // script formatting, tabs vs spaces, etc... 

        var server = new Server
        {
            ConnectionContext =
            {
                ConnectionString = Options.ConnectionString
            }
        };

        var database = server.Databases[Options.DatabaseName];

        var transfer = new Transfer(database)
        {
            Options = scriptOptions
        };

        using var file = File.Open(Options.SchemaFile, FileMode.Create);

        // use UTF8 without BOM to avoid issues
        // using var writer = new StreamWriter(file, new UnicodeEncoding(false, false));
        using var writer = new StreamWriter(file, new UTF8Encoding(false));

        // write out some metadata (mostly for sanity)
        var info = server.Information;
        writer.WriteLine("/*");
        writer.WriteLine($" Script generated by {Utilities.ToolName}");
        writer.WriteLine();
        writer.WriteLine(" Server Information:");
        writer.WriteLine($"  Product: {info.Product} [{info.ProductLevel}]");
        writer.WriteLine($"  Version: {info.VersionString}");
        writer.WriteLine($"  CLR Version: {info.BuildClrVersionString}");
        writer.WriteLine($"  Collation: {info.Collation}");
        // TODO: add other information about the server which may be helpful
        //  i.e. when upgrading the server, the differences will show up in git diffs if included here
        //  e.g. default values for ANSI_NULLS, QUOTED_IDENTIFIER, etc.
        writer.WriteLine();
        writer.WriteLine("*/");
        writer.WriteLine();
        writer.WriteLine($"USE [{DatabaseCommand.PrimaryDatabaseName}];");
        writer.WriteLine("GO");
        writer.WriteLine();

        // script out the database for it's options
        foreach (var script in database.Script())
        {
            if (script == null)
                continue;

            // skip the create database statement, since
            // we don't want the file groups and paths etc.
            // the generated script MUST be portable!
            if (script.StartsWith("CREATE DATABASE", StringComparison.InvariantCultureIgnoreCase))
                continue;

            // parameterize database name for portability!
            writer.Write(script.Replace(Options.DatabaseName, "$DatabaseName$"));
            writer.WriteLine();
            writer.WriteLine("GO");
            writer.WriteLine();
        }

        writer.WriteLine("USE [$DatabaseName$];");
        writer.WriteLine("GO");
        writer.WriteLine();

        /*****************************************************************
        // FIXME: figure out how SQL Management Studio does this using SMO
        // ***************************************************************
        // the following code has specific knowledge ALTER DATABASE DDL,
        // and ideally this tool should avoid database specifics.

        var configurations = database.DatabaseScopedConfigurations
            .Cast<DatabaseScopedConfiguration>()
            .OrderBy(x => x.Name);

        foreach (var configuration in configurations)
        {
            // BUG: this doesn't work - bug in SMO?
            // no need if the value is the default
            // if (configuration.IsValueDefault)
            //     continue;

            var name = configuration.Name;
            var value = configuration.Value;

            writer.WriteLine($"ALTER DATABASE SCOPED CONFIGURATION SET {name} = {value};");
            writer.WriteLine("GO");
            writer.WriteLine();

            if (string.IsNullOrWhiteSpace(configuration.ValueForSecondary)) continue;

            var secondaryValue = configuration.ValueForSecondary;
            writer.WriteLine(
                $"ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET {name} = {secondaryValue};");
            writer.WriteLine("GO");
            writer.WriteLine();
        }
        *****************************************************************/

        // extract all the remaining objects in the database
        // the generated script is identical to that generated via SQL Management Studio
        var scripts = transfer.ScriptTransfer();
        foreach (var script in scripts)
        {
            if (script == null)
                continue;

            // no other way to exclude "USE" and "CREATE USER" statements
            if (script.StartsWith("USE", StringComparison.InvariantCultureIgnoreCase) ||
                script.StartsWith("CREATE USER", StringComparison.InvariantCultureIgnoreCase))
                continue;

            writer.Write(script);
            writer.WriteLine();
            writer.WriteLine("GO");
            writer.WriteLine();
        }

        // jobs
        // ----------------------------------------------------------
        // this doesn't work, since requires `Agent XPs` to be enabled
        //
        //  EXEC sp_configure 'Agent XPs', 1;
        //
        // which doesn't work on container based SQL Server on Linux
        // ----------------------------------------------------------
        // var jobScripts = server.JobServer.Script();
        // foreach (var jobScript in jobScripts)
        // {
        //     if (jobScript == null)
        //         continue;
        //
        //     writer.Write(jobScript);
        //     writer.WriteLine();
        //     writer.WriteLine("GO");
        //     writer.WriteLine();
        // }

        // try get the SchemaVersionsTable table and script it out
        var schemaVersionsTable = database.Tables[SchemaVersionsTable];
        if (schemaVersionsTable != null)
        {
            // write out the migrations journal table
            writer.WriteLine();
            writer.WriteLine("/* Migrations Journal Data */");
            writer.WriteLine();

            var scripter = new Scripter(server)
            {
                Options =
                {
                    ScriptSchema = false,
                    ScriptData = true,
                    ScriptDrops = false,
                    SchemaQualify = true,
                    IncludeHeaders = false
                }
            };
            var dataRows = scripter.EnumScript(new SqlSmoObject[] { schemaVersionsTable });
            foreach (var dataRow in dataRows) writer.WriteLine(dataRow);

            writer.WriteLine("GO");
            writer.WriteLine();
        }

        // TODO: possibly include seed data tables here too?

        ReportSuccess($"Database schema dumped to '{Options.SchemaFile}' file.");
    }
}